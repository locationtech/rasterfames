<!DOCTYPE html>
<html lang="en" class="no-js">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="description" content="RasterFrames brings the power of Spark DataFrames to geospatial raster data.">
<meta name="generator" content="Paradox, paradox-material-theme=0.6.0, mkdocs-material=3.0.3">

<meta name="lang:clipboard.copy" content="Copy to clipboard">
<meta name="lang:clipboard.copied" content="Copied to clipboard">
<meta name="lang:search.language" content="">
<meta name="lang:search.pipeline.stopwords" content="true">
<meta name="lang:search.pipeline.trimmer" content="true">
<meta name="lang:search.result.none" content="No matching documents">
<meta name="lang:search.result.one" content="1 matching document">
<meta name="lang:search.result.other" content="# matching documents">
<meta name="lang:search.tokenizer" content="[\s\-]+">


<meta name="description" content="RasterFrames brings the power of Spark DataFrames to geospatial raster data.">
<link rel="shortcut icon" href="assets/images/RasterFrames_32x32.ico">
<title>Function Reference Â· RasterFrames</title>
<link rel="stylesheet" href="assets/stylesheets/application.451f80e5.css">
<link rel="stylesheet" href="assets/stylesheets/application-palette.22915126.css">
<meta name="theme-color" content="#546e7a" />
<link rel="stylesheet" href="lib/material__tabs/dist/mdc.tabs.min.css">
<link rel="stylesheet" href="lib/prettify/prettify.css">
<script src="assets/javascripts/modernizr.1aa3b519.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
<style>
body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}
code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}
</style>
<link rel="stylesheet" href="assets/fonts/font-awesome.css">
<link rel="stylesheet" href="assets/fonts/material-icons.css">
<link rel="stylesheet" href="assets/stylesheets/paradox-material-theme.css">
<link rel="stylesheet" href="assets/custom.css">
</head>
<body
data-md-color-primary="blue-grey"
data-md-color-accent="light-blue"
>
<input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
<input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
<label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
<header class="md-header" data-md-component="header">
<nav class="md-header-nav md-grid">
<div class="md-flex">
<div class="md-flex__cell md-flex__cell--shrink">
<a href="index.html" title="RasterFrames" class="md-header-nav__button md-logo">
<img src="assets/images/RF-R.svg" width="24" height="24">
</a>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
</div>
<div class="md-flex__cell md-flex__cell--stretch">
<div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
<span class="md-header-nav__topic">
RasterFrames
</span>
<span class="md-header-nav__topic">
Function Reference
</span>
</div>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
<div class="md-search" data-md-component="search" role="dialog">
<label class="md-search__overlay" for="__search"></label>
<div class="md-search__inner" role="search">
<form class="md-search__form" name="search">
<input type="text" class="md-search__input" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
<label class="md-icon md-search__icon" for="__search"></label>
<button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">&#xE5CD;</button>
</form>
<div class="md-search__output">
<div class="md-search__scrollwrap" data-md-scrollfix>
<div class="md-search-result" data-md-component="result">
<div class="md-search-result__meta">
Type to start searching
</div>
<ol class="md-search-result__list"></ol>
</div>
</div>
</div>
</div>
</div>

</div>
<div class="md-flex__cell md-flex__cell--shrink">
<div class="md-header-nav__source">
<a href="https://github.com/locationtech/rasterframes"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
locationtech/rasterframes
</div>
</a>

</div>
</div>
</div>
</nav>
</header>

<div class="md-container">
<main class="md-main">
<div class="md-main__inner md-grid" data-md-component="container">
<div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--primary" data-md-level="0" style="visibility: hidden">
<label class="md-nav__title md-nav__title--site" for="drawer">
<a href="index.html" title="RasterFrames" class="md-nav__button md-logo">
<span class="md-nav__button md-logo">
<img src="assets/images/RF-R.svg" width="24" height="24">
</a>
<a href="index.html" title="RasterFrames">
RasterFrames
</a>
</label>
<div class="md-nav__source">
<a href="https://github.com/locationtech/rasterframes"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
locationtech/rasterframes
</div>
</a>

</div>
<ul>
  <li><a href="description.html" class="page">Overview</a></li>
  <li><a href="getting-started.html" class="page">Getting Started</a></li>
  <li><a href="concepts.html" class="page">Concepts</a></li>
  <li><a href="raster-io.html" class="page">Raster Data I/O</a>
  <ul>
    <li><a href="raster-catalogs.html" class="page">Raster Catalogs</a></li>
    <li><a href="raster-read.html" class="page">Reading Raster Data</a></li>
    <li><a href="raster-write.html" class="page">Writing Raster Data</a></li>
  </ul></li>
  <li><a href="vector-data.html" class="page">Vector Data</a></li>
  <li><a href="raster-processing.html" class="page">Raster Processing</a>
  <ul>
    <li><a href="local-algebra.html" class="page">Local Map Algebra</a></li>
    <li><a href="nodata-handling.html" class="page">&ldquo;NoData&rdquo; Handling</a></li>
    <li><a href="masking.html" class="page">Masking</a></li>
    <li><a href="zonal-algebra.html" class="page">Zonal Map Algebra</a></li>
    <li><a href="aggregation.html" class="page">Aggregation</a></li>
    <li><a href="time-series.html" class="page">Time Series</a></li>
    <li><a href="raster-join.html" class="page">Raster Join</a></li>
  </ul></li>
  <li><a href="machine-learning.html" class="page">Machine Learning</a>
  <ul>
    <li><a href="unsupervised-learning.html" class="page">Unsupervised Machine Learning</a></li>
    <li><a href="supervised-learning.html" class="page">Supervised Machine Learning</a></li>
  </ul></li>
  <li><a href="numpy-pandas.html" class="page">NumPy and Pandas</a></li>
  <li><a href="ipython.html" class="page">IPython/Jupyter Extensions</a></li>
  <li><a href="languages.html" class="page">Scala and SQL</a></li>
  <li><a href="reference.html" class="active page">Function Reference</a></li>
  <li><a href="release-notes.html" class="page">Release Notes</a></li>
</ul>
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="reference.html#function-reference" class="header">Function Reference</a>
  <ul>
    <li><a href="reference.html#list-of-available-sql-and-python-functions" class="header">List of Available SQL and Python Functions</a></li>
    <li><a href="reference.html#vector-operations" class="header">Vector Operations</a></li>
    <li><a href="reference.html#tile-metadata-and-mutation" class="header">Tile Metadata and Mutation</a></li>
    <li><a href="reference.html#tile-creation" class="header">Tile Creation</a></li>
    <li><a href="reference.html#masking-and-nodata" class="header">Masking and NoData</a></li>
    <li><a href="reference.html#local-map-algebra" class="header">Local Map Algebra</a></li>
    <li><a href="reference.html#tile-statistics" class="header">Tile Statistics</a></li>
    <li><a href="reference.html#aggregate-tile-statistics" class="header">Aggregate Tile Statistics</a></li>
    <li><a href="reference.html#tile-local-aggregate-statistics" class="header">Tile Local Aggregate Statistics</a></li>
    <li><a href="reference.html#converting-tiles" class="header">Converting Tiles</a></li>
  </ul></li>
</ul>
</nav>

</nav>
<ul style="display: none">
<li class="md-nav__item md-version" id="project.version">
<label class="md-nav__link" for="__version">
<i class="md-icon" title="Version">label_outline</i> 0.9.1
</label>
</li>
</ul>
</div>
</div>
</div>
<div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="reference.html#function-reference" class="header">Function Reference</a>
  <ul>
    <li><a href="reference.html#list-of-available-sql-and-python-functions" class="header">List of Available SQL and Python Functions</a></li>
    <li><a href="reference.html#vector-operations" class="header">Vector Operations</a></li>
    <li><a href="reference.html#tile-metadata-and-mutation" class="header">Tile Metadata and Mutation</a></li>
    <li><a href="reference.html#tile-creation" class="header">Tile Creation</a></li>
    <li><a href="reference.html#masking-and-nodata" class="header">Masking and NoData</a></li>
    <li><a href="reference.html#local-map-algebra" class="header">Local Map Algebra</a></li>
    <li><a href="reference.html#tile-statistics" class="header">Tile Statistics</a></li>
    <li><a href="reference.html#aggregate-tile-statistics" class="header">Aggregate Tile Statistics</a></li>
    <li><a href="reference.html#tile-local-aggregate-statistics" class="header">Tile Local Aggregate Statistics</a></li>
    <li><a href="reference.html#converting-tiles" class="header">Converting Tiles</a></li>
  </ul></li>
</ul>
</nav>

</div>
</div>
</div>
<div class="md-content">
<article class="md-content__inner md-typeset">
<div class="md-content__searchable">
<h1><a href="#function-reference" name="function-reference" class="anchor"><span class="anchor-link"></span></a>Function Reference</h1>
<p>RasterFrames provides a rich set of columnar function for processing geospatial raster data. In Spark SQL, the functions are already registered in the SQL engine; they are usually prefixed with <code>rf_</code>. In Python, they are available in the <code>pyrasterframes.rasterfunctions</code> module.</p>
<p>The convention in this document will be to define the function signature as below, with its return type, the function name, and named arguments with their types.</p>
<pre><code>ReturnDataType function_name(InputDataType argument1, InputDataType argument2)
</code></pre>
<p>For the Scala documentation on these functions, see <a href="http://rasterframes.io/latest/api/org/locationtech/rasterframes/RasterFunctions.html"><code>RasterFunctions</code></a>. The full Scala API documentation can be found <a href="latest/api/index.html">here</a>.</p>
<pre class="prettyprint"><code class="language-python imports, echo=False">import pyrasterframes
from pyrasterframes.utils import create_rf_spark_session
from pyrasterframes.rasterfunctions import *
from IPython.display import display
import os.path

spark = create_rf_spark_session()
</code></pre>
<h2><a href="#list-of-available-sql-and-python-functions" name="list-of-available-sql-and-python-functions" class="anchor"><span class="anchor-link"></span></a>List of Available SQL and Python Functions</h2>
<div class="toc ">
<ul>
  <li><a href="reference.html#vector-operations" class="header">Vector Operations</a>
  <ul>
    <li><a href="reference.html#st-reproject" class="header">st_reproject</a></li>
    <li><a href="reference.html#st-extent" class="header">st_extent</a></li>
    <li><a href="reference.html#st-geometry" class="header">st_geometry</a></li>
    <li><a href="reference.html#rf-xz2-index" class="header">rf_xz2_index</a></li>
    <li><a href="reference.html#rf-z2-index" class="header">rf_z2_index</a></li>
  </ul></li>
  <li><a href="reference.html#tile-metadata-and-mutation" class="header">Tile Metadata and Mutation</a>
  <ul>
    <li><a href="reference.html#rf-dimensions" class="header">rf_dimensions</a></li>
    <li><a href="reference.html#rf-cell-type" class="header">rf_cell_type</a></li>
    <li><a href="reference.html#rf-tile" class="header">rf_tile</a></li>
    <li><a href="reference.html#rf-extent" class="header">rf_extent</a></li>
    <li><a href="reference.html#rf-crs" class="header">rf_crs</a></li>
    <li><a href="reference.html#rf-proj-raster" class="header">rf_proj_raster</a></li>
    <li><a href="reference.html#rf-mk-crs" class="header">rf_mk_crs</a></li>
    <li><a href="reference.html#rf-convert-cell-type" class="header">rf_convert_cell_type</a></li>
    <li><a href="reference.html#rf-interpret-cell-type-as" class="header">rf_interpret_cell_type_as</a></li>
    <li><a href="reference.html#rf-resample" class="header">rf_resample</a></li>
  </ul></li>
  <li><a href="reference.html#tile-creation" class="header">Tile Creation</a>
  <ul>
    <li><a href="reference.html#rf-make-zeros-tile" class="header">rf_make_zeros_tile</a></li>
    <li><a href="reference.html#rf-make-ones-tile" class="header">rf_make_ones_tile</a></li>
    <li><a href="reference.html#rf-make-constant-tile" class="header">rf_make_constant_tile</a></li>
    <li><a href="reference.html#rf-rasterize" class="header">rf_rasterize</a></li>
    <li><a href="reference.html#rf-array-to-tile" class="header">rf_array_to_tile</a></li>
    <li><a href="reference.html#rf-assemble-tile" class="header">rf_assemble_tile</a></li>
  </ul></li>
  <li><a href="reference.html#masking-and-nodata" class="header">Masking and NoData</a>
  <ul>
    <li><a href="reference.html#rf-mask" class="header">rf_mask</a></li>
    <li><a href="reference.html#rf-mask-by-value" class="header">rf_mask_by_value</a></li>
    <li><a href="reference.html#rf-mask-by-values" class="header">rf_mask_by_values</a></li>
    <li><a href="reference.html#rf-mask-by-bit" class="header">rf_mask_by_bit</a></li>
    <li><a href="reference.html#rf-mask-by-bits" class="header">rf_mask_by_bits</a></li>
    <li><a href="reference.html#rf-inverse-mask" class="header">rf_inverse_mask</a></li>
    <li><a href="reference.html#rf-inverse-mask-by-value" class="header">rf_inverse_mask_by_value</a></li>
    <li><a href="reference.html#rf-is-no-data-tile" class="header">rf_is_no_data_tile</a></li>
    <li><a href="reference.html#rf-local-no-data" class="header">rf_local_no_data</a></li>
    <li><a href="reference.html#rf-local-data" class="header">rf_local_data</a></li>
    <li><a href="reference.html#rf-local-data" class="header">rf_local_data</a></li>
    <li><a href="reference.html#rf-with-no-data" class="header">rf_with_no_data</a></li>
  </ul></li>
  <li><a href="reference.html#local-map-algebra" class="header">Local Map Algebra</a>
  <ul>
    <li><a href="reference.html#rf-local-add" class="header">rf_local_add</a></li>
    <li><a href="reference.html#rf-local-subtract" class="header">rf_local_subtract</a></li>
    <li><a href="reference.html#rf-local-multiply" class="header">rf_local_multiply</a></li>
    <li><a href="reference.html#rf-local-divide" class="header">rf_local_divide</a></li>
    <li><a href="reference.html#rf-normalized-difference" class="header">rf_normalized_difference</a></li>
    <li><a href="reference.html#rf-local-less" class="header">rf_local_less</a></li>
    <li><a href="reference.html#rf-local-less-equal" class="header">rf_local_less_equal</a></li>
    <li><a href="reference.html#rf-local-greater" class="header">rf_local_greater</a></li>
    <li><a href="reference.html#rf-local-greater-equal" class="header">rf_local_greater_equal</a></li>
    <li><a href="reference.html#rf-local-equal" class="header">rf_local_equal</a></li>
    <li><a href="reference.html#rf-local-unequal" class="header">rf_local_unequal</a></li>
    <li><a href="reference.html#rf-local-is-in" class="header">rf_local_is_in</a></li>
    <li><a href="reference.html#rf-local-extract-bits" class="header">rf_local_extract_bits</a></li>
    <li><a href="reference.html#rf-local-min" class="header">rf_local_min</a></li>
    <li><a href="reference.html#rf-local-max" class="header">rf_local_max</a></li>
    <li><a href="reference.html#rf-local-clamp" class="header">rf_local_clamp</a></li>
    <li><a href="reference.html#rf-where" class="header">rf_where</a></li>
    <li><a href="reference.html#rf-rescale" class="header">rf_rescale</a></li>
    <li><a href="reference.html#rf-standardize" class="header">rf_standardize</a></li>
    <li><a href="reference.html#rf-round" class="header">rf_round</a></li>
    <li><a href="reference.html#rf-abs" class="header">rf_abs</a></li>
    <li><a href="reference.html#rf-exp" class="header">rf_exp</a></li>
    <li><a href="reference.html#rf-exp10" class="header">rf_exp10</a></li>
    <li><a href="reference.html#rf-exp2" class="header">rf_exp2</a></li>
    <li><a href="reference.html#rf-expm1" class="header">rf_expm1</a></li>
    <li><a href="reference.html#rf-log" class="header">rf_log</a></li>
    <li><a href="reference.html#rf-log10" class="header">rf_log10</a></li>
    <li><a href="reference.html#rf-log2" class="header">rf_log2</a></li>
    <li><a href="reference.html#rf-log1p" class="header">rf_log1p</a></li>
    <li><a href="reference.html#rf-sqrt" class="header">rf_sqrt</a></li>
  </ul></li>
  <li><a href="reference.html#tile-statistics" class="header">Tile Statistics</a>
  <ul>
    <li><a href="reference.html#rf-tile-sum" class="header">rf_tile_sum</a></li>
    <li><a href="reference.html#rf-tile-mean" class="header">rf_tile_mean</a></li>
    <li><a href="reference.html#rf-tile-min" class="header">rf_tile_min</a></li>
    <li><a href="reference.html#rf-tile-max" class="header">rf_tile_max</a></li>
    <li><a href="reference.html#rf-no-data-cells" class="header">rf_no_data_cells</a></li>
    <li><a href="reference.html#rf-data-cells" class="header">rf_data_cells</a></li>
    <li><a href="reference.html#rf-exists" class="header">rf_exists</a></li>
    <li><a href="reference.html#rf-for-all" class="header">rf_for_all</a></li>
    <li><a href="reference.html#rf-tile-stats" class="header">rf_tile_stats</a></li>
    <li><a href="reference.html#rf-tile-histogram" class="header">rf_tile_histogram</a></li>
  </ul></li>
  <li><a href="reference.html#aggregate-tile-statistics" class="header">Aggregate Tile Statistics</a>
  <ul>
    <li><a href="reference.html#rf-agg-mean" class="header">rf_agg_mean</a></li>
    <li><a href="reference.html#rf-agg-data-cells" class="header">rf_agg_data_cells</a></li>
    <li><a href="reference.html#rf-agg-no-data-cells" class="header">rf_agg_no_data_cells</a></li>
    <li><a href="reference.html#rf-agg-stats" class="header">rf_agg_stats</a></li>
    <li><a href="reference.html#rf-agg-approx-histogram" class="header">rf_agg_approx_histogram</a></li>
    <li><a href="reference.html#rf-agg-approx-quantiles" class="header">rf_agg_approx_quantiles</a></li>
    <li><a href="reference.html#rf-agg-extent" class="header">rf_agg_extent</a></li>
    <li><a href="reference.html#rf-agg-reprojected-extent" class="header">rf_agg_reprojected_extent</a></li>
  </ul></li>
  <li><a href="reference.html#tile-local-aggregate-statistics" class="header">Tile Local Aggregate Statistics</a>
  <ul>
    <li><a href="reference.html#rf-agg-local-max" class="header">rf_agg_local_max</a></li>
    <li><a href="reference.html#rf-agg-local-min" class="header">rf_agg_local_min</a></li>
    <li><a href="reference.html#rf-agg-local-mean" class="header">rf_agg_local_mean</a></li>
    <li><a href="reference.html#rf-agg-local-data-cells" class="header">rf_agg_local_data_cells</a></li>
    <li><a href="reference.html#rf-agg-local-no-data-cells" class="header">rf_agg_local_no_data_cells</a></li>
    <li><a href="reference.html#rf-agg-local-stats" class="header">rf_agg_local_stats</a></li>
  </ul></li>
  <li><a href="reference.html#converting-tiles" class="header">Converting Tiles</a>
  <ul>
    <li><a href="reference.html#rf-explode-tiles" class="header">rf_explode_tiles</a></li>
    <li><a href="reference.html#rf-explode-tiles-sample" class="header">rf_explode_tiles_sample</a></li>
    <li><a href="reference.html#rf-tile-to-array-int" class="header">rf_tile_to_array_int</a></li>
    <li><a href="reference.html#rf-tile-to-array-double" class="header">rf_tile_to_array_double</a></li>
    <li><a href="reference.html#rf-render-ascii" class="header">rf_render_ascii</a></li>
    <li><a href="reference.html#rf-render-matrix" class="header">rf_render_matrix</a></li>
    <li><a href="reference.html#rf-render-png" class="header">rf_render_png</a></li>
    <li><a href="reference.html#rf-render-color-ramp-png" class="header">rf_render_color_ramp_png</a></li>
    <li><a href="reference.html#rf-agg-overview-raster" class="header">rf_agg_overview_raster</a></li>
    <li><a href="reference.html#rf-rgb-composite" class="header">rf_rgb_composite</a></li>
  </ul></li>
</ul>
</div>
<p>To import RasterFrames functions into the environment, import from <code>pyrasterframes.rasterfunctions</code>.</p>
<pre class="prettyprint"><code class="language-python">from pyrasterframes.rasterfunctions import *
</code></pre>
<p>Functions starting with <code>rf_</code>, which are for raster, and <code>st_</code>, which are for vector geometry, become available for use with DataFrames. You can view all of the available functions with the following.</p>
<pre class="prettyprint"><code class="language-python, evaluate=False">[fn for fn in dir() if fn.startswith(&#39;rf_&#39;) or fn.startswith(&#39;st_&#39;)]
</code></pre>
<h2><a href="#vector-operations" name="vector-operations" class="anchor"><span class="anchor-link"></span></a>Vector Operations</h2>
<p>Various LocationTech GeoMesa user-defined functions (UDFs) dealing with <code>geomtery</code> type columns are provided in the SQL engine and within the <code>pyrasterframes.rasterfunctions</code> Python module. These are documented in the <a href="https://www.geomesa.org/documentation/user/spark/sparksql_functions.html#">LocationTech GeoMesa Spark SQL documentation</a>. These functions are all prefixed with <code>st_</code>.</p>
<p>RasterFrames provides some additional functions for vector geometry operations.</p>
<h3><a href="#st-reproject" name="st-reproject" class="anchor"><span class="anchor-link"></span></a>st_reproject</h3>
<pre><code>Geometry st_reproject(Geometry geom, String origin_crs, String destination_crs)
</code></pre>
<p>Reproject the vector <code>geom</code> from <code>origin_crs</code> to <code>destination_crs</code>. Both <code>_crs</code> arguments are either <a href="https://proj4.org/usage/quickstart.html">proj4</a> strings, <a href="https://www.epsg-registry.org/">EPSG codes</a> or <a href="https://www.opengeospatial.org/standards/wkt-crs">OGC WKT</a> for coordinate reference systems.</p>
<h3><a href="#st-extent" name="st-extent" class="anchor"><span class="anchor-link"></span></a>st_extent</h3>
<pre><code>Struct[Double xmin, Double xmax, Double ymin, Double ymax] st_extent(Geometry geom)
</code></pre>
<p>Extracts the bounding box (extent/envelope) of the geometry.</p>
<p>See also GeoMesa <a href="https://www.geomesa.org/documentation/user/spark/sparksql_functions.html#st-envelope">st_envelope</a> which returns a Geometry type.</p>
<h3><a href="#st-geometry" name="st-geometry" class="anchor"><span class="anchor-link"></span></a>st_geometry</h3>
<pre><code>Geometry st_geometry(Struct[Double xmin, Double xmax, Double ymin, Double ymax] extent)
</code></pre>
<p>Convert an extent to a Geometry. The extent likely comes from <a href="reference.html#st-extent"><code>st_extent</code></a> or <a href="reference.html#rf-extent"><code>rf_extent</code></a>.</p>
<h3><a href="#rf-xz2-index" name="rf-xz2-index" class="anchor"><span class="anchor-link"></span></a>rf_xz2_index</h3>
<pre><code>Long rf_xz2_index(Geometry geom, CRS crs)
Long rf_xz2_index(Extent extent, CRS crs)
Long rf_xz2_index(ProjectedRasterTile proj_raster)
</code></pre>
<p>Constructs a XZ2 index in WGS84/EPSG:4326 from either a Geometry, Extent, ProjectedRasterTile and its CRS. This function is useful for <a href="http://spark.apache.org/docs/latest/api/python/pyspark.sql.html?highlight=registerjava#pyspark.sql.DataFrame.repartitionByRange">range partitioning</a>.</p>
<h3><a href="#rf-z2-index" name="rf-z2-index" class="anchor"><span class="anchor-link"></span></a>rf_z2_index</h3>
<pre><code>Long rf_z2_index(Geometry geom, CRS crs)
Long rf_z2_index(Extent extent, CRS crs)
Long rf_z2_index(ProjectedRasterTile proj_raster)
</code></pre>
<p>Constructs a Z2 index in WGS84/EPSG:4326 from either a Geometry, Extent, ProjectedRasterTile and its CRS. First the native extent is extracted or computed, and then center is used as the indexing location. This function is useful for <a href="http://spark.apache.org/docs/latest/api/python/pyspark.sql.html?highlight=registerjava#pyspark.sql.DataFrame.repartitionByRange">range partitioning</a>. See <a href="raster-read.html#spatial-indexing-and-partitioning">Reading Raster Data</a> section for details on how to have an index automatically added when reading raster data.</p>
<h2><a href="#tile-metadata-and-mutation" name="tile-metadata-and-mutation" class="anchor"><span class="anchor-link"></span></a>Tile Metadata and Mutation</h2>
<p>Functions to access and change the particulars of a <code>tile</code>: its shape and the data type of its cells. See section on <a href="nodata-handling.html">&ldquo;NoData&rdquo; handling</a> for additional discussion of cell types.</p>
<h3><a href="#rf-dimensions" name="rf-dimensions" class="anchor"><span class="anchor-link"></span></a>rf_dimensions</h3>
<pre><code>Struct[Int, Int] rf_dimensions(Tile tile)
</code></pre>
<p>Get number of columns and rows in the <code>tile</code>, as a Struct of <code>cols</code> and <code>rows</code>.</p>
<h3><a href="#rf-cell-type" name="rf-cell-type" class="anchor"><span class="anchor-link"></span></a>rf_cell_type</h3>
<pre><code>Struct[String] rf_cell_type(Tile tile)
</code></pre>
<p>Get the cell type of the <code>tile</code>. The cell type can be changed with <a href="reference.html#rf-convert-cell-type">rf_convert_cell_type</a>.</p>
<h3><a href="#rf-tile" name="rf-tile" class="anchor"><span class="anchor-link"></span></a>rf_tile</h3>
<pre><code>Tile rf_tile(ProjectedRasterTile proj_raster)
</code></pre>
<p>Get the fully realized (non-lazy) <code>tile</code> from a <code>ProjectedRasterTile</code> struct column.</p>
<h3><a href="#rf-extent" name="rf-extent" class="anchor"><span class="anchor-link"></span></a>rf_extent</h3>
<pre><code>Struct[Double xmin, Double xmax, Double ymin, Double ymax] rf_extent(ProjectedRasterTile proj_raster)
Struct[Double xmin, Double xmax, Double ymin, Double ymax] rf_extent(RasterSource proj_raster)
</code></pre>
<p>Fetches the extent (bounding box or envelope) of a <code>ProjectedRasterTile</code> or <code>RasterSource</code> type tile columns.</p>
<h3><a href="#rf-crs" name="rf-crs" class="anchor"><span class="anchor-link"></span></a>rf_crs</h3>
<pre><code>Struct rf_crs(ProjectedRasterTile proj_raster)
Struct rf_crs(RasterSource proj_raster)
Struct rf_crs(String crs_spec)
</code></pre>
<p>Fetch CRS structure representing the coordinate reference system of a <code>ProjectedRasterTile</code> or <code>RasterSource</code> type tile columns, or from a column of strings in the form supported by <a href="reference.html#rf-mk-crs"><code>rf_mk_crs</code></a>. </p>
<h3><a href="#rf-proj-raster" name="rf-proj-raster" class="anchor"><span class="anchor-link"></span></a>rf_proj_raster</h3>
<pre><code>ProjectedRasterTile rf_proj_raster(Tile tile, Extent extent, CRS crs)
</code></pre>
<p>Construct a <code>proj_raster</code> structure from individual Tile, Extent, and CRS columns.</p>
<h3><a href="#rf-mk-crs" name="rf-mk-crs" class="anchor"><span class="anchor-link"></span></a>rf_mk_crs</h3>
<pre><code>Struct rf_mk_crs(String crsText)   
</code></pre>
<p>Construct a CRS structure from one of its string representations. Three forms are supported:</p>
<ul>
  <li><a href="https://www.epsg-registry.org/">EPSG code</a>: <code>EPSG:&lt;integer&gt;</code></li>
  <li><a href="https://proj.org/">Proj4 string</a>: <code>+proj &lt;proj4 parameters&gt;</code></li>
  <li><a href="http://www.geoapi.org/3.0/javadoc/org/opengis/referencing/doc-files/WKT.html">WKT String</a> with embedded EPSG code: <code>GEOGCS[&quot;&lt;name&gt;&quot;, &lt;datum&gt;, &lt;prime meridian&gt;, &lt;angular unit&gt; {,&lt;twin axes&gt;} {,&lt;authority&gt;}]</code></li>
</ul>
<p>Example: <code>SELECT rf_mk_crs(&#39;EPSG:4326&#39;)</code></p>
<h3><a href="#rf-convert-cell-type" name="rf-convert-cell-type" class="anchor"><span class="anchor-link"></span></a>rf_convert_cell_type</h3>
<pre><code>Tile rf_convert_cell_type(Tile tile_col, CellType cell_type)
Tile rf_convert_cell_type(Tile tile_col, String cell_type)
</code></pre>
<p>Convert <code>tile_col</code> to a different cell type. In Python you can pass a CellType object to <code>cell_type</code>.</p>
<h3><a href="#rf-interpret-cell-type-as" name="rf-interpret-cell-type-as" class="anchor"><span class="anchor-link"></span></a>rf_interpret_cell_type_as</h3>
<pre><code>Tile rf_interpret_cell_type_as(Tile tile_col, CellType cell_type)
Tile rf_interpret_cell_type_as(Tile tile_col, String cell_type)
</code></pre>
<p>Change the interpretation of the <code>tile_col</code>&rsquo;s cell values according to specified <code>cell_type</code>. In Python you can pass a CellType object to <code>cell_type</code>.</p>
<h3><a href="#rf-resample" name="rf-resample" class="anchor"><span class="anchor-link"></span></a>rf_resample</h3>
<pre><code>Tile rf_resample(Tile tile, Double factor, [String method])
Tile rf_resample(Tile tile, Int factor, [String method])
Tile rf_resample(Tile tile, Tile shape_tile, [String method])
</code></pre>
<p>In <strong>SQL</strong>, three parameters are required for <code>rf_resample</code>.:</p>
<pre><code>Tile rf_resample(Tile tile, Double factor, String method)
Tile rf_resample(Tile tile, Int factor, String method)
Tile rf_resample(Tile tile, Tile shape_tile, String method)
Tile rf_resample_nearest(Tile tile, Double factor)
Tile rf_resample_nearest(Tile tile, Int factor)
Tile rf_resample_nearest(Tile tile, Tile shape_tile)
</code></pre>
<p>Change the tile dimension by upsampling or downsampling. Passing a numeric <code>factor</code> will scale the number of columns and rows in the tile: 1.0 is the same number of columns and row; less than one downsamples the tile; and greater than one upsamples the tile. Passing a tile as the second argument resamples such that the output has the same dimension (number of columns and rows) as <code>shape_tile</code>. </p>
<p>There are two categories: point resampling methods and aggregating resampling methods. Resampling method to use can be specified by one of the following strings, possibly in a column. The point resampling methods are: <code>&quot;nearest_neighbor&quot;</code>, <code>&quot;bilinear&quot;</code>, <code>&quot;cubic_convolution&quot;</code>, <code>&quot;cubic_spline&quot;</code>, and <code>&quot;lanczos&quot;</code>. The aggregating resampling methods are: <code>&quot;average&quot;</code>, <code>&quot;mode&quot;</code>, <code>&quot;median&quot;</code>, <code>&quot;max&quot;</code>, &ldquo;<code>min</code>&rdquo;, or <code>&quot;sum&quot;</code>.</p>
<p>Note the aggregating methods are intended for downsampling. For example a 0.25 factor and <code>max</code> method returns the maximum value in a 4x4 neighborhood.</p>
<p>If <code>tile</code> has an integer <code>CellType</code>, the returned tile will be coerced to a floating point with the following methods: bilinear, cubic_convolution, cubic_spline, lanczos, average, and median.</p>
<h2><a href="#tile-creation" name="tile-creation" class="anchor"><span class="anchor-link"></span></a>Tile Creation</h2>
<p>Functions to create a new Tile column, either from scratch or from existing data not yet in a <code>tile</code>.</p>
<h3><a href="#rf-make-zeros-tile" name="rf-make-zeros-tile" class="anchor"><span class="anchor-link"></span></a>rf_make_zeros_tile</h3>
<pre><code>Tile rf_make_zeros_tile(Int tile_columns, Int tile_rows, [CellType cell_type])
Tile rf_make_zeros_tile(Int tile_columns, Int tile_rows, [String cell_type_name])
</code></pre>
<p>Create a <code>tile</code> of shape <code>tile_columns</code> by <code>tile_rows</code> full of zeros, with the optional cell type; default is float64. See <a href="nodata-handling.html#cell-types">this discussion</a> on cell types for info on the <code>cell_type</code> argument. All arguments are literal values and not column expressions.</p>
<h3><a href="#rf-make-ones-tile" name="rf-make-ones-tile" class="anchor"><span class="anchor-link"></span></a>rf_make_ones_tile</h3>
<pre><code>Tile rf_make_ones_tile(Int tile_columns, Int tile_rows, [CellType cell_type])
Tile rf_make_ones_tile(Int tile_columns, Int tile_rows, [String cell_type_name])
</code></pre>
<p>Create a <code>tile</code> of shape <code>tile_columns</code> by <code>tile_rows</code> full of ones, with the optional cell type; default is float64. See <a href="nodata-handling.html#cell-types">this discussion</a> on cell types for info on the <code>cell_type</code> argument. All arguments are literal values and not column expressions.</p>
<h3><a href="#rf-make-constant-tile" name="rf-make-constant-tile" class="anchor"><span class="anchor-link"></span></a>rf_make_constant_tile</h3>
<pre><code>Tile rf_make_constant_tile(Numeric constant, Int tile_columns, Int tile_rows,  [CellType cell_type])
Tile rf_make_constant_tile(Numeric constant, Int tile_columns, Int tile_rows,  [String cell_type_name])
</code></pre>
<p>Create a <code>tile</code> of shape <code>tile_columns</code> by <code>tile_rows</code> full of <code>constant</code>, with the optional cell type; default is float64. See <a href="nodata-handling.html#cell-types">this discussion</a> on cell types for info on the <code>cell_type</code> argument. All arguments are literal values and not column expressions.</p>
<h3><a href="#rf-rasterize" name="rf-rasterize" class="anchor"><span class="anchor-link"></span></a>rf_rasterize</h3>
<pre><code>Tile rf_rasterize(Geometry geom, Geometry tile_bounds, Int value, Int tile_columns, Int tile_rows)
</code></pre>
<p>Convert a vector Geometry <code>geom</code> into a Tile representation. The <code>value</code> will be &ldquo;burned-in&rdquo; to the returned <code>tile</code> where the <code>geom</code> intersects the <code>tile_bounds</code>. Returned <code>tile</code> will have shape <code>tile_columns</code> by <code>tile_rows</code>. Values outside the <code>geom</code> will be assigned a NoData value. Returned <code>tile</code> has cell type <code>int32</code>, note that <code>value</code> is of type Int.</p>
<p>Parameters <code>tile_columns</code> and <code>tile_rows</code> are literals, not column expressions. The others are column expressions.</p>
<h3><a href="#rf-array-to-tile" name="rf-array-to-tile" class="anchor"><span class="anchor-link"></span></a>rf_array_to_tile</h3>
<pre><code>Tile rf_array_to_tile(Array arrayCol, Int numCols, Int numRows)
</code></pre>
<p>Python only. Create a <code>tile</code> from a Spark SQL <a href="http://spark.apache.org/docs/latest/api/python/pyspark.sql.html#pyspark.sql.types.ArrayType">Array</a>, filling values in row-major order.</p>
<h3><a href="#rf-assemble-tile" name="rf-assemble-tile" class="anchor"><span class="anchor-link"></span></a>rf_assemble_tile</h3>
<pre><code>Tile rf_assemble_tile(Int colIndex, Int rowIndex, Numeric cellData, Int numCols, Int numRows, [CellType cell_type])
Tile rf_assemble_tile(Int colIndex, Int rowIndex, Numeric cellData, Int numCols, Int numRows, [String cell_type_name])
</code></pre>
<p>SQL: <code>Tile rf_assemble_tile(Int colIndex, Int rowIndex, Numeric cellData, Int numCols, Int numRows)</code></p>
<p>Create <code>tile</code>s of dimension <code>numCols</code> by <code>numRows</code> from a column of cell data with location indices. This function is the inverse of <a href="reference.html#rf-explode-tiles"><code>rf_explode_tiles</code></a>. Intended use is with a <code>groupby</code>, producing one row with a new <code>tile</code> per group. In Python, the <code>numCols</code>, <code>numRows</code> and <code>cellType</code> arguments are literal values, others are column expressions. See <a href="nodata-handling.html#cell-types">this discussion</a> on cell types for info on the optional <code>cell_type</code> argument. The default is float64. SQL implementation does not accept a cell_type argument. It returns a float64 cell type <code>tile</code> by default.</p>
<h2><a href="#masking-and-nodata" name="masking-and-nodata" class="anchor"><span class="anchor-link"></span></a>Masking and NoData</h2>
<p>See the <a href="masking.html">masking</a> page for conceptual discussion of masking operations.</p>
<p>There are statistical functions of the count of data and NoData values per <code>tile</code> and aggregate over a <code>tile</code> column: <a href="reference.html#rf-data-cells"><code>rf_data_cells</code></a>, <a href="reference.html#rf-no-data-cells"><code>rf_no_data_cells</code></a>, <a href="reference.html#rf-agg-data-cells"><code>rf_agg_data_cells</code></a>, and <a href="reference.html#rf-agg-no-data-cells"><code>rf_agg_no_data_cells</code></a>.</p>
<p>Masking is a raster operation that sets specific cells to NoData based on the values in another raster.</p>
<h3><a href="#rf-mask" name="rf-mask" class="anchor"><span class="anchor-link"></span></a>rf_mask</h3>
<pre><code>Tile rf_mask(Tile tile, Tile mask, bool inverse)
</code></pre>
<p>Where the <code>mask</code> contains NoData, replace values in the <code>tile</code> with NoData.</p>
<p>Returned <code>tile</code> cell type will be coerced to one supporting NoData if it does not already.</p>
<p><code>inverse</code> is a literal not a Column. If <code>inverse</code> is true, return the <code>tile</code> with NoData in locations where the <code>mask</code> <em>does not</em> contain NoData. Equivalent to <a href="reference.html#rf-inverse-mask"><code>rf_inverse_mask</code></a>.</p>
<p>See also <a href="reference.html#rf-rasterize"><code>rf_rasterize</code></a>.</p>
<h3><a href="#rf-mask-by-value" name="rf-mask-by-value" class="anchor"><span class="anchor-link"></span></a>rf_mask_by_value</h3>
<pre><code>Tile rf_mask_by_value(Tile data_tile, Tile mask_tile, Int mask_value, bool inverse)
</code></pre>
<p>Generate a <code>tile</code> with the values from <code>data_tile</code>, with NoData in cells where the <code>mask_tile</code> is equal to <code>mask_value</code>.</p>
<p><code>inverse</code> is a literal not a Column. If <code>inverse</code> is true, return the <code>data_tile</code> with NoData in locations where the <code>mask_tile</code> value is <em>not equal</em> to <code>mask_value</code>. Equivalent to <a href="reference.html#rf-inverse-mask-by-value"><code>rf_inverse_mask_by_value</code></a>.</p>
<h3><a href="#rf-mask-by-values" name="rf-mask-by-values" class="anchor"><span class="anchor-link"></span></a>rf_mask_by_values</h3>
<pre><code>Tile rf_mask_by_values(Tile data_tile, Tile mask_tile, Array mask_values)
Tile rf_mask_by_values(Tile data_tile, Tile mask_tile, list mask_values)
</code></pre>
<p>Generate a <code>tile</code> with the values from <code>data_tile</code>, with NoData in cells where the <code>mask_tile</code> is in the <code>mask_values</code> Array or list. <code>mask_values</code> can be a <a href="http://spark.apache.org/docs/latest/api/python/pyspark.sql.html#pyspark.sql.types.ArrayType"><code>pyspark.sql.ArrayType</code></a> or a <code>list</code>. </p>
<h3><a href="#rf-mask-by-bit" name="rf-mask-by-bit" class="anchor"><span class="anchor-link"></span></a>rf_mask_by_bit</h3>
<pre><code>Tile rf_mask_by_bits(Tile tile, Tile mask_tile, Int bit_position, Bool mask_value) 
</code></pre>
<p>Applies a mask using bit values in the <code>mask_tile</code>. Working from the right, the bit at <code>bit_position</code> is <a href="reference.html#rf_local_extract_bits">extracted</a> from cell values of the <code>mask_tile</code>. In all locations where these are equal to the <code>mask_value</code>, the returned tile is set to NoData; otherwise the original <code>tile</code> cell value is returned.</p>
<p>This is a single-bit version of <a href="reference.html#rf-mask-by-bits"><code>rf_mask_by_bits</code></a>.</p>
<h3><a href="#rf-mask-by-bits" name="rf-mask-by-bits" class="anchor"><span class="anchor-link"></span></a>rf_mask_by_bits</h3>
<pre><code>Tile rf_mask_by_bits(Tile tile, Tile mask_tile, Int start_bit, Int num_bits, Array mask_values) 
Tile rf_mask_by_bits(Tile tile, Tile mask_tile, Int start_bit, Int num_bits, list mask_values) 
</code></pre>
<p>Applies a mask from blacklisted bit values in the <code>mask_tile</code>. Working from the right, the bits from <code>start_bit</code> to <code>start_bit + num_bits</code> are <a href="reference.html#rf_local_extract_bits">extracted</a> from cell values of the <code>mask_tile</code>. In all locations where these are in the <code>mask_values</code>, the returned tile is set to NoData; otherwise the original <code>tile</code> cell value is returned.</p>
<p>This function is not available in the SQL API. The below is equivalent:</p>
<pre class="prettyprint"><code class="language-sql">SELECT rf_mask_by_values(
            tile, 
            rf_local_extract_bits(mask_tile, start_bit, num_bits), 
            mask_values
            ),
</code></pre>
<h3><a href="#rf-inverse-mask" name="rf-inverse-mask" class="anchor"><span class="anchor-link"></span></a>rf_inverse_mask</h3>
<pre><code>Tile rf_inverse_mask(Tile tile, Tile mask)
</code></pre>
<p>Where the <code>mask</code> <em>does not</em> contain NoData, replace values in <code>tile</code> with NoData.</p>
<h3><a href="#rf-inverse-mask-by-value" name="rf-inverse-mask-by-value" class="anchor"><span class="anchor-link"></span></a>rf_inverse_mask_by_value</h3>
<pre><code>Tile rf_inverse_mask_by_value(Tile data_tile, Tile mask_tile, Int mask_value)
</code></pre>
<p>Generate a <code>tile</code> with the values from <code>data_tile</code>, with NoData in cells where the <code>mask_tile</code> is not equal to <code>mask_value</code>. In other words, only keep <code>data_tile</code> cells in locations where the <code>mask_tile</code> is equal to <code>mask_value</code>.</p>
<h3><a href="#rf-is-no-data-tile" name="rf-is-no-data-tile" class="anchor"><span class="anchor-link"></span></a>rf_is_no_data_tile</h3>
<pre><code>Boolean rf_is_no_data_tile(Tile)
</code></pre>
<p>Returns true if <code>tile</code> contains only NoData. By definition returns false if cell type does not support NoData. To count NoData cells or data cells, see <a href="reference.html#rf-no-data-cells"><code>rf_no_data_cells</code></a>, <a href="reference.html#rf-data-cells"><code>rf_data_cells</code></a>, <a href="reference.html#rf-agg-no-data-cells"><code>rf_agg_no_data_cells</code></a>, <a href="reference.html#rf-agg-data-cells"><code>rf_agg_data_cells</code></a>, <a href="reference.html#rf-agg-local-no-data-cells"><code>rf_agg_local_no_data_cells</code></a>, and <a href="reference.html#rf-agg-local-data-cells"><code>rf_agg_local_data_cells</code></a>. This function is distinguished from <a href="reference.html#rf-for-all"><code>rf_for_all</code></a>, which tests that values are not NoData and nonzero.</p>
<h3><a href="#rf-local-no-data" name="rf-local-no-data" class="anchor"><span class="anchor-link"></span></a>rf_local_no_data</h3>
<pre><code>Tile rf_local_no_data(Tile tile)
</code></pre>
<p>Returns a tile with values of 1 in each cell where the input tile contains NoData. Otherwise values are 0.</p>
<h3><a href="#rf-local-data" name="rf-local-data" class="anchor"><span class="anchor-link"></span></a>rf_local_data</h3>
<pre><code>Tile rf_local_no_data(Tile tile)
</code></pre>
<p>Returns a tile with values of 0 in each cell where the input tile contains NoData. Otherwise values are 1.</p>
<h3><a href="#rf-local-data" name="rf-local-data" class="anchor"><span class="anchor-link"></span></a>rf_local_data</h3>
<h3><a href="#rf-with-no-data" name="rf-with-no-data" class="anchor"><span class="anchor-link"></span></a>rf_with_no_data</h3>
<pre><code>Tile rf_with_no_data(Tile tile, Double no_data_value)
</code></pre>
<p>Python only. Return a <code>tile</code> column marking as NoData all cells equal to <code>no_data_value</code>.</p>
<p>The <code>no_data_value</code> argument is a literal Double, not a Column expression.</p>
<p>If input <code>tile</code> had a NoData value already, the behaviour depends on if its cell type is floating point or not. For floating point cell type <code>tile</code>, NoData values on the input <code>tile</code> remain NoData values on the output. For integral cell type <code>tile</code>s, the previous NoData values become literal values.</p>
<h2><a href="#local-map-algebra" name="local-map-algebra" class="anchor"><span class="anchor-link"></span></a>Local Map Algebra</h2>
<p><a href="https://gisgeography.com/map-algebra-global-zonal-focal-local/">Local map algebra</a> raster operations are element-wise operations on a single tile (unary), between a <code>tile</code> and a scalar, between two <code>tile</code>s, or across many <code>tile</code>s.</p>
<p>When these operations encounter a NoData value in either operand, the cell in the resulting <code>tile</code> will have a NoData.</p>
<p>The binary local map algebra functions have similar variations in the Python API depending on the left hand side type:</p>
<ul>
  <li><code>rf_local_op</code>: applies <code>op</code> to two columns; the right hand side can be a <code>tile</code> or a numeric column.</li>
  <li><code>rf_local_op_double</code>: applies <code>op</code> to a <code>tile</code> and a literal scalar, coercing the <code>tile</code> to a floating point type</li>
  <li><code>rf_local_op_int</code>: applies <code>op</code> to a <code>tile</code> and a literal scalar, without coercing the <code>tile</code> to a floating point type</li>
</ul>
<p>The SQL API does not require the <code>rf_local_op_double</code> or <code>rf_local_op_int</code> forms (just <code>rf_local_op</code>).</p>
<p>Local map algebra operations for more than two <code>tile</code>s are implemented to work across rows in the DataFrame. As such, they are <a href="reference.html#tile-local-aggregate-statistics">aggregate functions</a>.</p>
<h3><a href="#rf-local-add" name="rf-local-add" class="anchor"><span class="anchor-link"></span></a>rf_local_add</h3>
<pre><code>Tile rf_local_add(Tile tile1, Tile rhs)
Tile rf_local_add_int(Tile tile1, Int rhs)
Tile rf_local_add_double(Tile tile1, Double rhs)
</code></pre>
<p>Returns a <code>tile</code> column containing the element-wise sum of <code>tile1</code> and <code>rhs</code>.</p>
<h3><a href="#rf-local-subtract" name="rf-local-subtract" class="anchor"><span class="anchor-link"></span></a>rf_local_subtract</h3>
<pre><code>Tile rf_local_subtract(Tile tile1, Tile rhs)
Tile rf_local_subtract_int(Tile tile1, Int rhs)
Tile rf_local_subtract_double(Tile tile1, Double rhs)
</code></pre>
<p>Returns a <code>tile</code> column containing the element-wise difference of <code>tile1</code> and <code>rhs</code>.</p>
<h3><a href="#rf-local-multiply" name="rf-local-multiply" class="anchor"><span class="anchor-link"></span></a>rf_local_multiply</h3>
<pre><code>Tile rf_local_multiply(Tile tile1, Tile rhs)
Tile rf_local_multiply_int(Tile tile1, Int rhs)
Tile rf_local_multiply_double(Tile tile1, Double rhs)
</code></pre>
<p>Returns a <code>tile</code> column containing the element-wise product of <code>tile1</code> and <code>rhs</code>. This is <strong>not</strong> the matrix multiplication of <code>tile1</code> and <code>rhs</code>.</p>
<h3><a href="#rf-local-divide" name="rf-local-divide" class="anchor"><span class="anchor-link"></span></a>rf_local_divide</h3>
<pre><code>Tile rf_local_divide(Tile tile1, Tile rhs)
Tile rf_local_divide_int(Tile tile1, Int rhs)
Tile rf_local_divide_double(Tile tile1, Double rhs)
</code></pre>
<p>Returns a <code>tile</code> column containing the element-wise quotient of <code>tile1</code> and <code>rhs</code>.</p>
<h3><a href="#rf-normalized-difference" name="rf-normalized-difference" class="anchor"><span class="anchor-link"></span></a>rf_normalized_difference</h3>
<pre><code>Tile rf_normalized_difference(Tile tile1, Tile tile2)
</code></pre>
<p>Compute the normalized difference of the the two <code>tile</code>s: <code>(tile1 - tile2) / (tile1 + tile2)</code>. Result is always floating point cell type. This function has no scalar variant.</p>
<h3><a href="#rf-local-less" name="rf-local-less" class="anchor"><span class="anchor-link"></span></a>rf_local_less</h3>
<pre><code>Tile rf_local_less(Tile tile1, Tile rhs)
Tile rf_local_less_int(Tile tile1, Int rhs)
Tile rf_local_less_double(Tile tile1, Double rhs)
</code></pre>
<p>Returns a <code>tile</code> column containing the element-wise evaluation of <code>tile1</code> is less than <code>rhs</code>.</p>
<h3><a href="#rf-local-less-equal" name="rf-local-less-equal" class="anchor"><span class="anchor-link"></span></a>rf_local_less_equal</h3>
<pre><code>Tile rf_local_less_equal(Tile tile1, Tile rhs)
Tile rf_local_less_equal_int(Tile tile1, Int rhs)
Tile rf_local_less_equal_double(Tile tile1, Double rhs)
</code></pre>
<p>Returns a <code>tile</code> column containing the element-wise evaluation of <code>tile1</code> is less than or equal to <code>rhs</code>.</p>
<h3><a href="#rf-local-greater" name="rf-local-greater" class="anchor"><span class="anchor-link"></span></a>rf_local_greater</h3>
<pre><code>Tile rf_local_greater(Tile tile1, Tile rhs)
Tile rf_local_greater_int(Tile tile1, Int rhs)
Tile rf_local_greater_double(Tile tile1, Double rhs)
</code></pre>
<p>Returns a <code>tile</code> column containing the element-wise evaluation of <code>tile1</code> is greater than <code>rhs</code>.</p>
<h3><a href="#rf-local-greater-equal" name="rf-local-greater-equal" class="anchor"><span class="anchor-link"></span></a>rf_local_greater_equal</h3>
<pre><code>Tile rf_local_greater_equal(Tile tile1, Tile rhs)
Tile rf_local_greater_equal_int(Tile tile1, Int rhs)
Tile rf_local_greater_equal_double(Tile tile1, Double rhs)
</code></pre>
<p>Returns a <code>tile</code> column containing the element-wise evaluation of <code>tile1</code> is greater than or equal to <code>rhs</code>.</p>
<h3><a href="#rf-local-equal" name="rf-local-equal" class="anchor"><span class="anchor-link"></span></a>rf_local_equal</h3>
<pre><code>Tile rf_local_equal(Tile tile1, Tile rhs)
Tile rf_local_equal_int(Tile tile1, Int rhs)
Tile rf_local_equal_double(Tile tile1, Double rhs)
</code></pre>
<p>Returns a <code>tile</code> column containing the element-wise equality of <code>tile1</code> and <code>rhs</code>.</p>
<h3><a href="#rf-local-unequal" name="rf-local-unequal" class="anchor"><span class="anchor-link"></span></a>rf_local_unequal</h3>
<pre><code>Tile rf_local_unequal(Tile tile1, Tile rhs)
Tile rf_local_unequal_int(Tile tile1, Int rhs)
Tile rf_local_unequal_double(Tile tile1, Double rhs)
</code></pre>
<p>Returns a <code>tile</code> column containing the element-wise inequality of <code>tile1</code> and <code>rhs</code>.</p>
<h3><a href="#rf-local-is-in" name="rf-local-is-in" class="anchor"><span class="anchor-link"></span></a>rf_local_is_in</h3>
<pre><code>Tile rf_local_is_in(Tile tile, Array array)
Tile rf_local_is_in(Tile tile, list l)
</code></pre>
<p>Returns a <code>tile</code> column with cell values of 1 where the <code>tile</code> cell value is in the provided array or list. The <code>array</code> is a Spark SQL <a href="http://spark.apache.org/docs/latest/api/python/pyspark.sql.html#pyspark.sql.types.ArrayType">Array</a>. A python <code>list</code> of numeric values can also be passed.</p>
<h3><a href="#rf-local-extract-bits" name="rf-local-extract-bits" class="anchor"><span class="anchor-link"></span></a>rf_local_extract_bits</h3>
<pre><code>Tile rf_local_extract_bits(Tile tile, Int start_bit, Int num_bits)
Tile rf_local_extract_bits(Tile tile, Int start_bit)
</code></pre>
<p>Extract value from specified bits of the cells&rsquo; underlying binary data. Working from the right, the bits from <code>start_bit</code> to <code>start_bit + num_bits</code> are extracted from cell values of the <code>tile</code>. The <code>start_bit</code> is zero indexed. If <code>num_bits</code> is not provided, a single bit is extracted.</p>
<p>A common use case for this function is covered by <a href="reference.html#rf-mask-by-bits"><code>rf_mask_by_bits</code></a>.</p>
<h3><a href="#rf-local-min" name="rf-local-min" class="anchor"><span class="anchor-link"></span></a>rf_local_min</h3>
<pre><code>Tile rf_local_min(Tile tile, Tile max)
Tile rf_local_min(Tile tile, Numeric max)
</code></pre>
<p>Performs cell-wise minimum two tiles or a tile and a scalar.</p>
<h3><a href="#rf-local-max" name="rf-local-max" class="anchor"><span class="anchor-link"></span></a>rf_local_max</h3>
<pre><code>Tile rf_local_max(Tile tile, Tile max)
Tile rf_local_max(Tile tile, Numeric max)
</code></pre>
<p>Performs cell-wise maximum two tiles or a tile and a scalar.</p>
<h3><a href="#rf-local-clamp" name="rf-local-clamp" class="anchor"><span class="anchor-link"></span></a>rf_local_clamp</h3>
<pre><code>Tile rf_local_clamp(Tile tile, Tile min, Tile max)
Tile rf_local_clamp(Tile tile, Numeric min, Tile max)
Tile rf_local_clamp(Tile tile, Tile min, Numeric max)
Tile rf_local_clamp(Tile tile, Numeric min, Numeric max)
</code></pre>
<p>Return the tile with its values limited to a range defined by min and max, inclusive. </p>
<h3><a href="#rf-where" name="rf-where" class="anchor"><span class="anchor-link"></span></a>rf_where</h3>
<pre><code>Tile rf_where(Tile condition, Tile x, Tile y)
</code></pre>
<p>Return a tile with cell values chosen from <code>x</code> or <code>y</code> depending on <code>condition</code>. Operates cell-wise in a similar fashion to Spark SQL <code>when</code> and <code>otherwise</code>.</p>
<h3><a href="#rf-rescale" name="rf-rescale" class="anchor"><span class="anchor-link"></span></a>rf_rescale</h3>
<pre><code>Tile rf_rescale(Tile tile)
Tile rf_rescale(Tile tile, Double min, Double max)
</code></pre>
<p>Rescale cell values such that the minimum is zero and the maximum is one. Other values will be linearly interpolated into the range. If specified, the <code>min</code> parameter will become the zero value and the <code>max</code> parameter will become 1. See <a href="reference.html#rf_agg_stats"><code>rf_agg_stats</code></a>. Values outside the range will be set to 0 or 1. If <code>min</code> and <code>max</code> are not specified, the <strong>tile-wise</strong> minimum and maximum are used; this can result in inconsistent values across rows in a tile column.</p>
<h3><a href="#rf-standardize" name="rf-standardize" class="anchor"><span class="anchor-link"></span></a>rf_standardize</h3>
<pre><code>rf_standardize(Tile tile)
rf_standardize(Tile tile, Double mean, Double stddev)
</code></pre>
<p>Standardize cell values such that the mean is zero and the standard deviation is one. If specified, the <code>mean</code> and <code>stddev</code> are applied to all tiles in the column. See <a href="reference.html#rf_agg_stats"><code>rf_agg_stats</code></a>. If not specified, each tile will be standardized according to the statistics of its cell values; this can result in inconsistent values across rows in a tile column.</p>
<h3><a href="#rf-round" name="rf-round" class="anchor"><span class="anchor-link"></span></a>rf_round</h3>
<pre><code>Tile rf_round(Tile tile)
</code></pre>
<p>Round cell values to the nearest integer without changing the cell type.</p>
<h3><a href="#rf-abs" name="rf-abs" class="anchor"><span class="anchor-link"></span></a>rf_abs</h3>
<pre><code>Tile rf_abs(Tile tile)
</code></pre>
<p>Compute the absolute value of cell value.</p>
<h3><a href="#rf-exp" name="rf-exp" class="anchor"><span class="anchor-link"></span></a>rf_exp</h3>
<pre><code>Tile rf_exp(Tile tile)
</code></pre>
<p>Performs cell-wise exponential.</p>
<h3><a href="#rf-exp10" name="rf-exp10" class="anchor"><span class="anchor-link"></span></a>rf_exp10</h3>
<pre><code>Tile rf_exp10(Tile tile)
</code></pre>
<p>Compute 10 to the power of cell values.</p>
<h3><a href="#rf-exp2" name="rf-exp2" class="anchor"><span class="anchor-link"></span></a>rf_exp2</h3>
<pre><code>Tile rf_exp2(Tile tile)
</code></pre>
<p>Compute 2 to the power of cell values.</p>
<h3><a href="#rf-expm1" name="rf-expm1" class="anchor"><span class="anchor-link"></span></a>rf_expm1</h3>
<pre><code>Tile rf_expm1(Tile tile)
</code></pre>
<p>Performs cell-wise exponential, then subtract one. Inverse of <a href="reference.html#log1p"><code>log1p</code></a>.</p>
<h3><a href="#rf-log" name="rf-log" class="anchor"><span class="anchor-link"></span></a>rf_log</h3>
<pre><code>Tile rf_log(Tile tile)
</code></pre>
<p>Performs cell-wise natural logarithm.</p>
<h3><a href="#rf-log10" name="rf-log10" class="anchor"><span class="anchor-link"></span></a>rf_log10</h3>
<pre><code>Tile rf_log10(Tile tile)
</code></pre>
<p>Performs cell-wise logarithm with base 10.</p>
<h3><a href="#rf-log2" name="rf-log2" class="anchor"><span class="anchor-link"></span></a>rf_log2</h3>
<pre><code>Tile rf_log2(Tile tile)
</code></pre>
<p>Performs cell-wise logarithm with base 2.</p>
<h3><a href="#rf-log1p" name="rf-log1p" class="anchor"><span class="anchor-link"></span></a>rf_log1p</h3>
<pre><code>Tile rf_log1p(Tile tile)
</code></pre>
<p>Performs natural logarithm of cell values plus one. Inverse of <a href="reference.html#rf-expm1"><code>rf_expm1</code></a>.</p>
<h3><a href="#rf-sqrt" name="rf-sqrt" class="anchor"><span class="anchor-link"></span></a>rf_sqrt</h3>
<pre><code> Tile rf_sqrt(Tile tile)
</code></pre>
<p>Perform cell-wise square root.</p>
<h2><a href="#tile-statistics" name="tile-statistics" class="anchor"><span class="anchor-link"></span></a>Tile Statistics</h2>
<p>The following functions compute a statistical summary per row of a <code>tile</code> column. The statistics are computed across the cells of a single <code>tile</code>, within each DataFrame Row.</p>
<h3><a href="#rf-tile-sum" name="rf-tile-sum" class="anchor"><span class="anchor-link"></span></a>rf_tile_sum</h3>
<pre><code>Double rf_tile_sum(Tile tile)
</code></pre>
<p>Computes the sum of cells in each row of column <code>tile</code>, ignoring NoData values.</p>
<h3><a href="#rf-tile-mean" name="rf-tile-mean" class="anchor"><span class="anchor-link"></span></a>rf_tile_mean</h3>
<pre><code>Double rf_tile_mean(Tile tile)
</code></pre>
<p>Computes the mean of cells in each row of column <code>tile</code>, ignoring NoData values.</p>
<h3><a href="#rf-tile-min" name="rf-tile-min" class="anchor"><span class="anchor-link"></span></a>rf_tile_min</h3>
<pre><code>Double rf_tile_min(Tile tile)
</code></pre>
<p>Computes the min of cells in each row of column <code>tile</code>, ignoring NoData values.</p>
<h3><a href="#rf-tile-max" name="rf-tile-max" class="anchor"><span class="anchor-link"></span></a>rf_tile_max</h3>
<pre><code>Double rf_tile_max(Tile tile)
</code></pre>
<p>Computes the max of cells in each row of column <code>tile</code>, ignoring NoData values.</p>
<h3><a href="#rf-no-data-cells" name="rf-no-data-cells" class="anchor"><span class="anchor-link"></span></a>rf_no_data_cells</h3>
<pre><code>Long rf_no_data_cells(Tile tile)
</code></pre>
<p>Return the count of NoData cells in the <code>tile</code>.</p>
<h3><a href="#rf-data-cells" name="rf-data-cells" class="anchor"><span class="anchor-link"></span></a>rf_data_cells</h3>
<pre><code>Long rf_data_cells(Tile tile)
</code></pre>
<p>Return the count of data cells in the <code>tile</code>.</p>
<h3><a href="#rf-exists" name="rf-exists" class="anchor"><span class="anchor-link"></span></a>rf_exists</h3>
<pre><code>Boolean rf_exists(Tile tile)
</code></pre>
<p>Returns true if any cells in the tile are true (non-zero and not NoData).</p>
<h3><a href="#rf-for-all" name="rf-for-all" class="anchor"><span class="anchor-link"></span></a>rf_for_all</h3>
<pre><code>Boolean rf_for_all(Tile tile)
</code></pre>
<p>Returns true if all cells in the tile are true (non-zero and not NoData). See also <a href="reference.html#rf-is-no-data-tile">`rf_is_no_data_tile</a>, which tests that all cells are NoData.</p>
<h3><a href="#rf-tile-stats" name="rf-tile-stats" class="anchor"><span class="anchor-link"></span></a>rf_tile_stats</h3>
<pre><code>Struct[Long, Long, Double, Double, Double, Double] rf_tile_stats(Tile tile)
</code></pre>
<p>Computes the following statistics of cells in each row of column <code>tile</code>: data cell count, NoData cell count, minimum, maximum, mean, and variance. The minimum, maximum, mean, and variance are computed ignoring NoData values. Resulting column has the below schema.</p>
<pre class="prettyprint"><code class="language-python echo=False">spark.sql(&quot;SELECT rf_tile_stats(rf_make_ones_tile(5, 5, &#39;float32&#39;)) as tile_stats&quot;).printSchema()
</code></pre>
<h3><a href="#rf-tile-histogram" name="rf-tile-histogram" class="anchor"><span class="anchor-link"></span></a>rf_tile_histogram</h3>
<pre><code>Struct[Array[Struct[Double, Long]]] rf_tile_histogram(Tile tile)
</code></pre>
<p>Computes a count of cell values within each row of <code>tile</code>. The <code>bins</code> array is of tuples of histogram values and counts. Typically values are plotted on the x-axis and counts on the y-axis. Resulting column has the below schema. Related is the <a href="reference.html#rf-agg-approx-histogram"><code>rf_agg_approx_histogram</code></a> which computes the statistics across all rows in a group.</p>
<pre class="prettyprint"><code class="language-python echo=False">spark.sql(&quot;SELECT rf_tile_histogram(rf_make_ones_tile(5, 5, &#39;float32&#39;)) as tile_histogram&quot;).printSchema()
</code></pre>
<h2><a href="#aggregate-tile-statistics" name="aggregate-tile-statistics" class="anchor"><span class="anchor-link"></span></a>Aggregate Tile Statistics</h2>
<p>These functions compute statistical summaries over all of the cell values <em>and</em> across all the rows in the DataFrame or group.</p>
<h3><a href="#rf-agg-mean" name="rf-agg-mean" class="anchor"><span class="anchor-link"></span></a>rf_agg_mean</h3>
<pre><code>Double rf_agg_mean(Tile tile)
</code></pre>
<p><em>SQL</em>: <a href="reference.html#rf-agg-stats"><code>rf_agg_stats</code></a><code>(tile).mean</code></p>
<p>Aggregates over the <code>tile</code> and return the mean of cell values, ignoring NoData. Equivalent to <a href="reference.html#rf-agg-stats"><code>rf_agg_stats</code></a><code>.mean</code>.</p>
<h3><a href="#rf-agg-data-cells" name="rf-agg-data-cells" class="anchor"><span class="anchor-link"></span></a>rf_agg_data_cells</h3>
<pre><code>Long rf_agg_data_cells(Tile tile)
</code></pre>
<p><em>SQL</em>: <a href="reference.html#rf-agg-stats"><code>rf_agg_stats</code></a><code>(tile).data_cells</code></p>
<p>Aggregates over the <code>tile</code> and return the count of data cells. Equivalent to <a href="reference.html#rf-agg-stats"><code>rf_agg_stats</code></a><code>.dataCells</code>.</p>
<h3><a href="#rf-agg-no-data-cells" name="rf-agg-no-data-cells" class="anchor"><span class="anchor-link"></span></a>rf_agg_no_data_cells</h3>
<pre><code>Long rf_agg_no_data_cells(Tile tile)
</code></pre>
<p><em>SQL</em>: <a href="reference.html#rf-agg-stats"><code>rf_agg_stats</code></a><code>(tile).no_data_cells</code></p>
<p>Aggregates over the <code>tile</code> and return the count of NoData cells. Equivalent to <a href="reference.html#rf-agg-stats"><code>rf_agg_stats</code></a><code>.noDataCells</code>. C.F. <a href="reference.html#rf-no-data-cells"><code>rf_no_data_cells</code></a> a row-wise count of no data cells.</p>
<h3><a href="#rf-agg-stats" name="rf-agg-stats" class="anchor"><span class="anchor-link"></span></a>rf_agg_stats</h3>
<pre><code>Struct[Long, Long, Double, Double, Double, Double] rf_agg_stats(Tile tile)
</code></pre>
<p>Aggregates over the <code>tile</code> and returns statistical summaries of cell values: number of data cells, number of NoData cells, minimum, maximum, mean, and variance. The minimum, maximum, mean, and variance ignore the presence of NoData.</p>
<h3><a href="#rf-agg-approx-histogram" name="rf-agg-approx-histogram" class="anchor"><span class="anchor-link"></span></a>rf_agg_approx_histogram</h3>
<pre><code>Struct[Array[Struct[Double, Long]]] rf_agg_approx_histogram(Tile tile)
</code></pre>
<p>Aggregates over all of the rows in DataFrame of <code>tile</code> and returns a count of each cell value to create a histogram with values are plotted on the x-axis and counts on the y-axis. Related is the <a href="reference.html#rf-tile-histogram"><code>rf_tile_histogram</code></a> function which operates on a single row at a time.</p>
<h3><a href="#rf-agg-approx-quantiles" name="rf-agg-approx-quantiles" class="anchor"><span class="anchor-link"></span></a>rf_agg_approx_quantiles</h3>
<pre><code>Array[Double] rf_agg_approx_quantiles(Tile tile, List[float] probabilities, float relative_error)
</code></pre>
<p><strong>Not supported in SQL.</strong></p>
<p>Calculates the approximate quantiles of a tile column of a DataFrame. <code>probabilities</code> is a list of float values at which to compute the quantiles. These must belong to [0, 1]. For example 0 is the minimum, 0.5 is the median, 1 is the maximum. Returns an array of values approximately at the specified <code>probabilities</code>.</p>
<h3><a href="#rf-agg-extent" name="rf-agg-extent" class="anchor"><span class="anchor-link"></span></a>rf_agg_extent</h3>
<pre><code>Extent rf_agg_extent(Extent extent)
</code></pre>
<p>Compute the naive aggregate extent over a column. Assumes CRS homogeneity. With mixed CRS in the column, or if you are unsure, use <a href="reference.html#rf-agg-reprojected-extent"><code>rf_agg_reprojected_extent</code></a>.</p>
<h3><a href="#rf-agg-reprojected-extent" name="rf-agg-reprojected-extent" class="anchor"><span class="anchor-link"></span></a>rf_agg_reprojected_extent</h3>
<pre><code>Extent rf_agg_reprojected_extent(Extent extent, CRS source_crs, String dest_crs)
</code></pre>
<p>Compute the aggregate extent over the <code>extent</code> and <code>source_crs</code> columns. The <code>dest_crs</code> is given as a string. Each row&rsquo;s extent will be reprojected to the <code>dest_crs</code> before aggregating. </p>
<h2><a href="#tile-local-aggregate-statistics" name="tile-local-aggregate-statistics" class="anchor"><span class="anchor-link"></span></a>Tile Local Aggregate Statistics</h2>
<p>Local statistics compute the element-wise statistics across a DataFrame or group of <code>tile</code>s, resulting in a <code>tile</code> that has the same dimension.</p>
<p>When these functions encounter NoData in a cell location, it will be ignored. </p>
<h3><a href="#rf-agg-local-max" name="rf-agg-local-max" class="anchor"><span class="anchor-link"></span></a>rf_agg_local_max</h3>
<pre><code>Tile rf_agg_local_max(Tile tile)
</code></pre>
<p>Compute the cell-local maximum operation over <code>tile</code>s in a column.</p>
<h3><a href="#rf-agg-local-min" name="rf-agg-local-min" class="anchor"><span class="anchor-link"></span></a>rf_agg_local_min</h3>
<pre><code>Tile rf_agg_local_min(Tile tile)
</code></pre>
<p>Compute the cell-local minimum operation over <code>tile</code>s in a column.</p>
<h3><a href="#rf-agg-local-mean" name="rf-agg-local-mean" class="anchor"><span class="anchor-link"></span></a>rf_agg_local_mean</h3>
<pre><code>Tile rf_agg_local_mean(Tile tile)
</code></pre>
<p>Compute the cell-local mean operation over <code>tile</code>s in a column.</p>
<h3><a href="#rf-agg-local-data-cells" name="rf-agg-local-data-cells" class="anchor"><span class="anchor-link"></span></a>rf_agg_local_data_cells</h3>
<pre><code>Tile rf_agg_local_data_cells(Tile tile)
</code></pre>
<p>Compute the cell-local count of data cells over <code>tile</code>s in a column. Returned <code>tile</code> has a cell type of <code>int32</code>.</p>
<h3><a href="#rf-agg-local-no-data-cells" name="rf-agg-local-no-data-cells" class="anchor"><span class="anchor-link"></span></a>rf_agg_local_no_data_cells</h3>
<pre><code>Tile rf_agg_local_no_data_cells(Tile tile)
</code></pre>
<p>Compute the cell-local count of NoData cells over <code>tile</code>s in a column. Returned <code>tile</code> has a cell type of <code>int32</code>.</p>
<h3><a href="#rf-agg-local-stats" name="rf-agg-local-stats" class="anchor"><span class="anchor-link"></span></a>rf_agg_local_stats</h3>
<pre><code>Struct[Tile, Tile, Tile, Tile, Tile] rf_agg_local_stats(Tile tile)
</code></pre>
<p>Compute cell-local aggregate count, minimum, maximum, mean, and variance for a column of <code>tile</code>s. Returns a struct of five <code>tile</code>s.</p>
<h2><a href="#converting-tiles" name="converting-tiles" class="anchor"><span class="anchor-link"></span></a>Converting Tiles</h2>
<p>RasterFrames provides several ways to convert a <code>tile</code> into other data structures. See also functions for <a href="reference.html#tile-creation">creating tiles</a>.</p>
<h3><a href="#rf-explode-tiles" name="rf-explode-tiles" class="anchor"><span class="anchor-link"></span></a>rf_explode_tiles</h3>
<pre><code>Int, Int, Numeric* rf_explode_tiles(Tile* tile)
</code></pre>
<p>Create a row for each cell in <code>tile</code> columns. Many <code>tile</code> columns can be passed in, and the returned DataFrame will have one numeric column per input. There will also be columns for <code>column_index</code> and <code>row_index</code>. Inverse of <a href="reference.html#rf-assemble-tile"><code>rf_assemble_tile</code></a>. When using this function, be sure to have a unique identifier for rows in order to successfully invert the operation.</p>
<h3><a href="#rf-explode-tiles-sample" name="rf-explode-tiles-sample" class="anchor"><span class="anchor-link"></span></a>rf_explode_tiles_sample</h3>
<pre><code>Int, Int, Numeric* rf_explode_tiles_sample(Double sample_frac, Long seed, Tile* tile)
</code></pre>
<p>Python only. As with <a href="reference.html#rf-explode-tiles"><code>rf_explode_tiles</code></a>, but taking a randomly sampled subset of cells. Equivalent to the <code>rf_explode-tiles</code>, but allows a random subset of the data to be selected. Parameter <code>sample_frac</code> should be between 0.0 and 1.0.</p>
<h3><a href="#rf-tile-to-array-int" name="rf-tile-to-array-int" class="anchor"><span class="anchor-link"></span></a>rf_tile_to_array_int</h3>
<pre><code>Array rf_tile_to_array_int(Tile tile)
</code></pre>
<p>Convert Tile column to Spark SQL <a href="http://spark.apache.org/docs/latest/api/python/pyspark.sql.html#pyspark.sql.types.ArrayType">Array</a>, in row-major order. Float cell types will be coerced to integral type by flooring.</p>
<h3><a href="#rf-tile-to-array-double" name="rf-tile-to-array-double" class="anchor"><span class="anchor-link"></span></a>rf_tile_to_array_double</h3>
<pre><code>Array rf_tile_to_arry_double(Tile tile)
</code></pre>
<p>Convert tile column to Spark <a href="http://spark.apache.org/docs/latest/api/python/pyspark.sql.html#pyspark.sql.types.ArrayType">Array</a>, in row-major order. Integral cell types will be coerced to floats.</p>
<h3><a href="#rf-render-ascii" name="rf-render-ascii" class="anchor"><span class="anchor-link"></span></a>rf_render_ascii</h3>
<pre><code>String rf_render_ascii(Tile tile)
</code></pre>
<p>Pretty print the tile values as plain text.</p>
<h3><a href="#rf-render-matrix" name="rf-render-matrix" class="anchor"><span class="anchor-link"></span></a>rf_render_matrix</h3>
<pre><code>String rf_render_matrix(Tile tile)
</code></pre>
<p>Render Tile cell values as a string of numeric values, for debugging purposes.</p>
<h3><a href="#rf-render-png" name="rf-render-png" class="anchor"><span class="anchor-link"></span></a>rf_render_png</h3>
<pre><code>Array rf_render_png(Tile red, Tile green, Tile blue)
</code></pre>
<p>Converts three tile columns to a three-channel PNG-encoded image <code>bytearray</code>. First evaluates <a href="reference.md#rf-rgb-composite"><code>rf_rgb_composite</code></a> on the given tile columns, and then encodes the result. For more about rendering these in a Jupyter or IPython environment, see @<a href="raster-write.md#rendering-samples-with-color">Writing Raster Data</a>.</p>
<h3><a href="#rf-render-color-ramp-png" name="rf-render-color-ramp-png" class="anchor"><span class="anchor-link"></span></a>rf_render_color_ramp_png</h3>
<pre><code>Array rf_render_png(Tile tile, String color_ramp_name)
</code></pre>
<p>Converts given tile into a PNG image, using a color ramp of the given name to convert cells into pixels. <code>color_ramp_name</code> can be one of the following:</p>
<ul>
  <li>&ldquo;BlueToOrange&rdquo;</li>
  <li>&ldquo;LightYellowToOrange&rdquo;</li>
  <li>&ldquo;BlueToRed&rdquo;</li>
  <li>&ldquo;GreenToRedOrange&rdquo;</li>
  <li>&ldquo;LightToDarkSunset&rdquo;</li>
  <li>&ldquo;LightToDarkGreen&rdquo;</li>
  <li>&ldquo;HeatmapYellowToRed&rdquo;</li>
  <li>&ldquo;HeatmapBlueToYellowToRedSpectrum&rdquo;</li>
  <li>&ldquo;HeatmapDarkRedToYellowWhite&rdquo;</li>
  <li>&ldquo;HeatmapLightPurpleToDarkPurpleToWhite&rdquo;</li>
  <li>&ldquo;ClassificationBoldLandUse&rdquo;</li>
  <li>&ldquo;ClassificationMutedTerrain&rdquo;</li>
  <li>&ldquo;Magma&rdquo;</li>
  <li>&ldquo;Inferno&rdquo;</li>
  <li>&ldquo;Plasma&rdquo;</li>
  <li>&ldquo;Viridis&rdquo;</li>
  <li>&ldquo;Greyscale2&rdquo;</li>
  <li>&ldquo;Greyscale8&rdquo;</li>
  <li>&ldquo;Greyscale32&rdquo;</li>
  <li>&ldquo;Greyscale64&rdquo;</li>
  <li>&ldquo;Greyscale128&rdquo;</li>
  <li>&ldquo;Greyscale256&rdquo;</li>
</ul>
<p>Further descriptions of these color ramps can be found in the <a href="https://geotrellis.readthedocs.io/en/latest/guide/rasters.html#built-in-color-ramps">Geotrellis Documentation</a>. For more about rendering these in a Jupyter or IPython environment, see @<a href="raster-write.md#rendering-samples-with-color">Writing Raster Data</a>.</p>
<h3><a href="#rf-agg-overview-raster" name="rf-agg-overview-raster" class="anchor"><span class="anchor-link"></span></a>rf_agg_overview_raster</h3>
<pre><code>Tile rf_agg_overview_raster(Tile proj_raster_col, int cols, int rows, Extent aoi)
Tile rf_agg_overview_raster(Tile tile_col, int cols, int rows, Extent aoi, Extent tile_extent_col, CRS tile_crs_col)
</code></pre>
<p>Construct an overview <em>tile</em> of size <code>cols</code> by <code>rows</code>. Data is filtered to the specified <code>aoi</code> which is given in web mercator. Uses bi-linear sampling method. The <code>tile_extent_col</code> and <code>tile_crs_col</code> arguments are optional if the first argument has its Extent and CRS embedded.</p>
<h3><a href="#rf-rgb-composite" name="rf-rgb-composite" class="anchor"><span class="anchor-link"></span></a>rf_rgb_composite</h3>
<pre><code>Tile rf_rgb_composite(Tile red, Tile green, Tile blue)
</code></pre>
<p>Merges three bands into a single byte-packed RGB composite. It first scales each cell to fit into an unsigned byte, in the range 0-255, and then merges all three channels to fit into a 32-bit unsigned integer. This is useful when you want an RGB tile to render or to process with other color imagery tools. </p>
</div>
<div>
<a href="https://github.com/locationtech/rasterframes/tree/v0.9.1/docs/src/main/paradox/reference.md" title="Edit this page" class="md-source-file md-edit">
Edit this page
</a>
</div>
<div class="print-only">
<span class="md-source-file md-version">
0.9.1
</span>
</div>
</article>
</div>
</div>
</main>
<footer class="md-footer">
<div class="md-footer-nav">
<nav class="md-footer-nav__inner md-grid">
<a href="languages.html" title="Scala and SQL" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
</div>
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Previous
</span>
Scala and SQL
</span>
</div>
</a>
<a href="release-notes.html" title="Release Notes" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Next
</span>
Release Notes
</span>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
</div>
</a>
</nav>
</div>
<div class="md-footer-meta md-typeset">
<div class="md-footer-meta__inner md-grid">
<div class="md-footer-copyright">
<div class="md-footer-copyright__highlight">
&copy; 2017-2019 <a href="https://astraea.earth">Astraea</a>, Inc. All rights reserved.
</div>
</div>
</div>
</div>
</footer>

</div>
<script src="assets/javascripts/application.583bbe55.js"></script>
<script src="assets/javascripts/paradox-material-theme.js"></script>
<script>app.initialize({version:"0.17",url:{base:"."}})</script>
<script type="text/javascript" src="lib/prettify/prettify.js"></script>
<script type="text/javascript" src="lib/prettify/lang-scala.js"></script>
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
window.prettyPrint && prettyPrint();
});
</script>
<script>!function(e,a,t,n,o,c,i){e.GoogleAnalyticsObject=o,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=1*new Date,c=a.createElement(t),i=a.getElementsByTagName(t)[0],c.async=1,c.src="https://www.google-analytics.com/analytics.js",i.parentNode.insertBefore(c,i)}(window,document,"script",0,"ga"),ga("create","UA-106630615-1"),ga("set","anonymizeIp",!0),ga("send","pageview");var links=document.getElementsByTagName("a");Array.prototype.map.call(links,function(e){e.host!=document.location.host&&e.addEventListener("click",function(){var a=e.getAttribute("data-md-action")||"follow";ga("send","event","outbound",a,e.href)})});if(document.forms.search){var query=document.forms.search.query;query.addEventListener("blur",function(){if(this.value){var e=document.location.pathname;ga("send","pageview",e+"?q="+this.value)}})}</script>

</body>
</html>
