# "NoData" Handling

## What is NoData?

In raster operations, the preservation and correct processing of missing observations is very important. In [most dataframes and scientific computing](https://www.oreilly.com/learning/handling-missing-data), the idea of missing data is expressed as a null or NaN value. A great deal of raster data is stored for space efficiency. This typically leads to use of integral values and a "sentinel" value to represent missing observations. This sentinel value varies across data products and is usually called the NoData value. 

RasterFrames provides a variety of functions to inspect and manage NoData within `tile`s. 

## Cell Types

To understand how NoData is handled in RasterFrames, we first need to understand the different underlying types of data called cell types. The cell types are GeoTrellis `CellType`s, so the [GeoTrellis documentation](https://geotrellis.readthedocs.io/en/latest/guide/core-concepts.html?#working-with-cell-values) is a valuable resource on how these are defined.

```python setup, echo=False
import pyrasterframes
from pyrasterframes.rasterfunctions import *
import pyrasterframes.rf_ipython
from IPython.display import display

spark = pyrasterframes.get_spark_session()
```

The `CellType` class from the `rf_types` submodule allows us to create a representation of any valid cell type. There are convenience methods to create instances for a variety of basic types.

```python celltype_ctors
from pyrasterframes.rf_types import CellType
import inspect

[c[0] for c in inspect.getmembers(CellType, inspect.ismethod)]
```

We can also inspect the cell type of a given _tile_ or `proj_raster` column.

```python ct_from_sen
spark.read.raster('https://s22s-test-geotiffs.s3.amazonaws.com/luray_snp/B02.tif') \
    .select(rf_cell_type('proj_raster')).distinct().show()
```

### Understanding Cell Types and NoData

Use the methods on the `CellType` class to learn more about a specific cell type. Take for example the cell type of our sample data above.

```python
ct = CellType('uint16raw')
ct, ct.is_floating_point(), ct.has_no_data()
```

We can see that for the above data source, there is no defined NoData value. This means that each value is interpreted as a valid observation. Often such data is meant to be combined with another band indicating the quality of observations at each location. The lack of NoData is indicated by the `raw` at the end of the type name. Consider also the `uint16` cell type.

```python
from pyrasterframes.rf_types import CellType
ct = CellType('uint16')
ct, ct.is_floating_point(), ct.has_no_data(), ct.no_data_value()
```

In this case, the minimum value of 0 is designated as the NoData value. For integral valued cell types, the NoData is typically zero, the maximum, or the minimum value for the underlying data type. The NoData value can also be a user-defined value. In that case the value is designated with a `ud`. 

```python
CellType.uint16().with_no_data_value(99).cell_type_name
```

Floating point types by default have `NaN` as the NoData value. However a user-defined NoData can be set. 

```python float_ud
print(CellType.float32().no_data_value())
print(CellType.float32().with_no_data_value(-99.9).no_data_value())
```

## Masking

Let's continue the example above with Sentinel-2 data. Band 2 is blue and has no defined NoData. The quality information is in a separate file called the scene classification (SCL), which delineates areas of missing data and probable clouds. For much more information on that, see the [Sentinel-2 algorithm overview](https://earth.esa.int/web/sentinel/technical-guides/sentinel-2-msi/level-2a/algorithm). Figure 3 tells us how to interpret the scene classification. For this example, we will exclude NoData, defective pixels, probable clouds, and cirrus clouds: values 0, 1, 8, 9, and 10.

The first step is to create a catalog with our band of interest and the SCL band. We read the data from the catalog and now the blue band and SCL tiles are aligned across rows.

```python blue_scl_cat
from pyspark.sql import Row

blue_uri = 'https://s22s-test-geotiffs.s3.amazonaws.com/luray_snp/B02.tif'
scl_uri = 'https://s22s-test-geotiffs.s3.amazonaws.com/luray_snp/SCL.tif'
cat = spark.createDataFrame([Row(blue=blue_uri, scl=scl_uri),])
unmasked = spark.read.raster(catalog=cat, catalog_col_names=['blue', 'scl'])
unmasked.printSchema()
unmasked.select(rf_cell_type('blue'), rf_cell_type('scl')).distinct().show()
```

Drawing on @ref:[local map algebra](local-algebra.md) techniques, we will create a new tile column containing our indicator of unwanted pixels, as defined above.

```python def_mask
from pyspark.sql.functions import lit

mask_part = unmasked.withColumn('nodata', rf_local_equal('scl', lit(0))) \
                    .withColumn('defect', rf_local_equal('scl', lit(1))) \
                    .withColumn('cloud8', rf_local_equal('scl', lit(8))) \
                    .withColumn('cloud9', rf_local_equal('scl', lit(9))) \
                    .withColumn('cirrus', rf_local_equal('scl', lit(10))) 

one_mask = mask_part.withColumn('mask', rf_local_add('nodata', 'defect')) \
                    .withColumn('mask', rf_local_add('mask', 'cloud8')) \
                    .withColumn('mask', rf_local_add('mask', 'cloud9')) \
                    .withColumn('mask', rf_local_add('mask', 'cirrus'))

one_mask.select(rf_cell_type('mask')).distinct().show()
```

Now we will use the @ref:[`rf_mask_by_value`](reference.md#rf-mask-by-value) to designate the cloudy and other unwanted pixels as NoData in the blue column. Because there is not a NoData already defined, we will choose one. Note that in this particular example the minimum value is greater than zero, so we can use 0 as the NoData value.

```python pick_nd
one_mask.agg(rf_agg_stats('blue').min.alias('blue_min')).show()
```

We can now construct the cell type string for our blue band's cell type, but designating 0 as NoData.

```python get_ct_string
blue_ct = one_mask.select(rf_cell_type('blue')).distinct().first()[0][0]
masked_blue_ct = CellType(blue_ct).with_no_data_value(0)
masked_blue_ct.cell_type_name
```

Convert the cell type and apply the mask. Since the mask column is bit type, the addition done above was equivalent to a logical or. So the true values are 1.

```python mask_blu 
with_nd = rf_convert_cell_type('blue', masked_blue_ct.cell_type_name)
masked = one_mask.withColumn('blue_masked', 
                             rf_mask_by_value(with_nd, 'mask', lit(1))) \
                 .drop('nodata', 'defect', 'cloud8', 'cloud9', 'cirrus', 'blue')
```

We can verify that the number of NoData cells in the resulting `blue_masked` column matches the total of the bit-type `mask` tile.

```python
masked.select(rf_no_data_cells('blue_masked'), rf_tile_sum('mask')).show(10)
```

It's also nice to view a sample.

```python show_masked
sample = masked.orderBy(-rf_no_data_cells('blue_masked')).select(rf_tile('blue_masked'), rf_tile('scl')).first()
display(sample[0])
```

And the original SCL data.

```python show_scl
display(sample[1])
```

## NoData in Arithmetic Operations

local algebra example; same celltype what happens to nodata 
Possibly use st_geomFromWkt and rf_rasterize to create something to work from

agg


## Dealing with Multiple Cell Types

Quick demo of one ND tile one raw tile

Quick demo of ND in two different cell types


